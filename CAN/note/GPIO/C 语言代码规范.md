#                                                                                       高质量 C 代码规范

**作者**：disnox(https://www.disnox.top/)

**文档版本**：版本1.0 (2023-6-15)

[TOC]

<div style="page-break-after:always"></div>

## 1. 文件结构

每个 C 程序通常分为两个文件：

+ 一个文件用于保存程序的声明（declaration），称为头文件。
+ 另一个文件用于保存程序的实现（implementation），称为定义（definition）文件。

> 注意：C程序的头文件以“.h”为后缀，C程序的定义文件以“.c”为后缀。

### 1.1 版权和版本的声明

版权和版本的声明位于头文件和定义文件的开头，主要内容有：

+ 版权信息。
+ 文件名称，标识符，摘要。
+ 当前版本号，作者/修改者，完成日期。
+ 版本历史信息。

示例1-1：版权和版本的声明

```c
/**
************************************************************************
* @Copyright (c) 2023, xxxxxxxxx
* All rights reserved. 
*  
* @filename：filename.h 
* @brief：简要描述本文件的内容
*  
* @version：1.1
* @author：输入作者（或修改者）名字
* @date：20023年6月20日
* 
* @ReplaceVersion：1.0 
* @author：输入原作者（或修改者）名字
* @date：2023年5月10日
************************************************************************
**/
```

### 1.2 头文件的结构

头文件由三部分内容组成：

+ 头文件开头处的版权和版本声明（参见示例1-1）。
+ 预处理块。
+ 函数和类结构声明等。

> 【规则1-2-1】为了防止头文件被重复引用，应当用 ifndef/define/endif 结构产生预处理块。
>
> 【规则1-2-2】用 #include <filename.h>  格式来引用标准库的头文件（编译器将从标准库目录开始搜索）。
>
> 【规则1-2-3】用 #include “filename.h”  格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。

> 【建议1-2-1】头文件中一般只存放“声明”而不存放“定义”，建议将成员函数的定义与声明分开，不论该函数体有多么小。
>
> 【建议1-2-2】不提倡使用全局变量，尽量不要在头文件中出现象extern int value 这类声明。

示例 1-2：example.h 的 C 头文件结构

```c
// 版权和版本声明见示例1-1，此处省略。

#ifndef  __EXAMPLE_H__  // 防止example.h被重复引用
#define  __EXAMPLE_H__  

#include <math.h>     	// 引用标准库的头文件⋯
#include “myheader.h”   // 引用非标准库的头文件⋯

typedef struct
{
    ......
}Example_Typedef;		// 结构体定义
			
void function(⋯);  	// 全局函数声明⋯  

#endif 
```

### 1.3 定义文件的结构

定义文件有三部分内容：

+ 定义文件开头处的版权和版本声明。
+ 对一些头文件的引用。
+ 程序的实现体（包括数据和代码）。

示例 1-3：定义文件的结构

```c
// 版权和版本声明见示例1-1，此处省略。

#include “example.h”	// 引用头文件⋯

Example_Typedef EX;		// 结构体声明

// 全局函数的实现体
void function(⋯) 
{ 
	......
} 

```

### 1.4 头文件的作用

+ 通过头文件来调用库功能。在很多场合，源代码不便向用户公布，只要向用户提供头文件和二进制的库即可。
+ 用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。
+ 头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误。

### 1.5 目录结构

如果一个软件的头文件数目比较多（如超过十个），通常应将头文件和定义文件分别保存于不同的目录，以便于维护。

例如可将头文件保存于include目录，将定义文件保存于source目录（可以是多级目录）。

如果某些头文件是私有的，它不会被用户的程序直接引用，则没有必要公开其“声明”。为了加强信息隐藏，这些私有的头文件可以和定义文件存放于同一个目录。



---

## 2 程序的版式

版式虽然不会影响程序的功能，但会影响可读性。程序的版式追求清晰、美观，是程序风格的重要构成因素。

可以把程序的版式比喻为“书法”。好的“书法”可让人对程序一目了然，看得兴致勃勃。差的程序“书法”如螃蟹爬行，让人看得索然无味，更令维护者烦恼有加。请程序员们学习程序的“书法”，弥补大学计算机教育的漏洞，实在很有必要。

### 2.1 空行

空行起着分隔程序段落的作用。空行得体（不过多也不过少）将使程序的布局更加清晰。空行不会浪费内存，虽然打印含有空行的程序是会多消耗一些纸张，但是值得。所以不要舍不得用空行。

+ 【规则2-1-1】在每个类声明之后、每个函数定义结束之后都要加空行。

示例 2-1(a)：

```c
// 空行
void function1(⋯) 
{
    ⋯ 
} 
// 空行
void function2(⋯) 
{ 
    ⋯ 
} 
// 空行
void function3(⋯) 
{ 
    ⋯ 
} 
```

+ 【规则2-1-2】在一个函数体内，逻揖上密切相关的语句之间不加空行，其它地方应加空行分隔。

示例 2-1(b)：

```c
// 空行
while (condition) 
{   
	statement1;    
 	//  空行  
 	if  (condition)      
 	{        
   	 	statement2;    
 	}    
 	else    
 	{        
     	statement3;    
 	}  
	// 空行  
	statement4;  
}  
```

### 2.2 代码行

+ 【规则2-2-1】一行代码只做一件事情，如只定义一个变量，或只写一条语句。这样的代码容易阅读，并且方便于写注释。

+ 【规则2-2-2】if、for、while、do等语句自占一行，执行语句不得紧跟其后。不论执行语句有多少都要加{}。这样可以防止书写失误。

示例 2-2(a)：风格良好的代码行

```c
int width;   // 宽度
int height;  // 高度
int depth;   // 深度

x = a + b; 
y = c + d; 
z = e + f;

if (width < height)  
{ 
    dosomething(); 
} 

for (initialization; condition; update) 
{ 
    dosomething(); 
} 
// 空行
other(); 
```

示例 2-2(b)：风格不良的代码行

```c
int width, height, depth; // 宽度高度深度

X ＝ a + b;   y = c + d;  z = e + f; 

if (width < height) dosomething(); 

for (initialization; condition; update)      
    dosomething(); 
other(); 
```

+ 【建议2-2-1】尽可能在定义变量的同时初始化该变量（就近原则）如果变量的引用处和其定义处相隔比较远，变量的初始化很容易被忘记。如果引用了未被初始化的变量，可能会导致程序错误。本建议可以减少隐患。

例如：

```c
int width = 10;   // 定义并初绐化width  
int height = 10;  // 定义并初绐化height  
int depth = 10;    // 定义并初绐化depth  
```

### 2.3 代码行内的空格

+ 【规则2-3-1】关键字之后要留空格。象const、virtual、inline、case 等关键字之后至少要留一个空格，否则无法辨析关键字。象if、for、while等关键字之后应留一个空格再跟左括号‘（’，以突出关键字。

+ 【规则2-3-2】函数名之后不要留空格，紧跟左括号‘（’，以与关键字区别）。

+ 【规则2-3-3】‘（’向后紧跟，‘）’、‘，’、‘;’向前紧跟，紧跟处不留空格。

+ 【规则2-3-4】‘，’之后要留空格，如Function(x, y, z)。如果‘;’不是一行的结束符号，其后要留空格，如for (initialization; condition; update)。

+ 【规则2-3-5】赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符，如“=”、“+=”“>=”、“<=”、“+”、“*”、“%”、“&&”、“||”、“<<”,“^”等二元操作符的前后应当加空格。

+ 【规则2-3-6】一元操作符如“!”、“~”、“++”、“--”、“&”（地址运算符）等前后不加空格。

+ 【规则2-3-7】象“［］”、“.”、“->”这类操作符前后不加空格。

+ 【建议2-3-1】对于表达式比较长的for语句和if语句，为了紧凑起见可以适当地去掉一些空格，如for (i=0; i<10; i++)和if ((a<=b) && (c<=d)) 

示例 2-3：代码行内的空格

```c
void func1(int x, int y, int z);          // 良好的风格
void func1 (int x,int y,int z);           // 不良的风格

if (year >= 2000)                         // 良好的风格
if(year>=2000)                            // 不良的风格
if ((a>=b) && (c<=d))                     // 良好的风格
if(a>=b&&c<=d)                            // 不良的风格

for (i=0; i<10; i++)                      // 良好的风格
for(i=0;i<10;i++)                         // 不良的风格
for (i = 0; i < 10; i ++)                 // 过多的空格
    
x = a < b ? a : b;                        // 良好的风格
x=a<b?a:b;                                // 不良的风格

int *x = &y;                              // 良好的风格
int * x = & y;                            // 不良的风格

array[5] = 0;                             // 不要写成 array [ 5 ] = 0; 
a.function();                             // 不要写成 a . Function(); 
b->function();                            // 不要写成 b -> Function(); 
```

### 2.4 对齐

+ 【规则2-4-1】程序的分界符 ‘ { ’ 和 ‘ } ’ 应独占一行并且位于同一列，同时与引用它们的语句左对齐。

+ 【规则2-4-2】{ } 之内的代码块在 ‘ { ’ 右边数格处左对齐。

示例 2-4(a)：风格良好的对齐

```c
void function(int x) 
{ 
    ⋯ // program code 
} 

if (condition) 
{ 
    ⋯ // program code 
} 
else 
{ 
    ⋯ // program code 
} 

for (initialization; condition; update) 
{ 
    ⋯ // program code 
} 

While (condition) 
{
    ⋯ // program code 
} 

/* 如果出现嵌套的｛｝，则使用缩进对齐，如：*/    
	{     
        ⋯               
        {    
            ⋯               
        }     
        ⋯
    } 
```

示例 2-4(b)：风格不良的对齐

```c
void function(int x) { 
    ⋯ // program code 
} 

if (condition) { 
    ⋯ // program code 
} 
else { 
    ⋯ // program code 
} 

for (initialization; condition; update) {
    ⋯ // program code 
} 

while (condition) { 
    ⋯ // program code 
} 
```

### 2.5 长行拆分

+ 【规则2-5-1】代码行最大长度宜控制在70至80个字符以内。代码行不要过长，否则眼睛看不过来，也不便于打印。

+ 【规则2-5-2】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当的缩进，使排版整齐，语句可读。

示例 2-5：长行拆分

```c
if ((very_longer_variable1 >= very_longer_variable12) 
    && (very_longer_variable3 <= very_longer_variable14) 
    && (very_longer_variable5 <= very_longer_variable16)) 
{     
    dosomething(); 
} 

for (very_longer_initialization;         
     very_longer_condition;            
     very_longer_update)    
{     
    dosomething();    
} 
```

### 2.6 修饰符的位置

修饰符  * 和  ＆  应该靠近数据类型还是该靠近变量名，是个有争议的活题。

若将修饰符 * 靠近数据类型，例如：int*  x; 从语义上讲此写法比较直观，即x是int 类型的指针。

上述写法的弊端是容易引起误解，例如：int*  x, y; 此处y容易被误解为指针变量。虽然将x和y分行定义可以避免误解，但并不是人人都愿意这样做。

+ 【规则2-6-1】应当将修饰符  *  和＆紧靠变量名

例如：

```c
char  *name;     
int   *x, y;   // 此处y不会被误解为指针
```

### 2.7 注释

C 语言中，程序块的注释常采用 “/*...*/”，行注释一般采用 “//...”。

注释通常用于：

（1）版本、版权声明；

（2）函数接口说明；

（3）重要的代码行或段落提示。

虽然注释有助于理解代码，但注意不可过多地使用注释。

+ 【规则2-7-1】注释是对代码的“提示”，而不是文档。程序中的注释不可喧宾夺主，注释太多了会让人眼花缭乱。注释的花样要少。

+ 【规则2-7-2】如果代码本来就是清楚的，则不必加注释。否则多此一举，令人厌烦。例如i++;    // i 加 1，多余的注释
+ 【规则2-7-3】边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。
+ 【规则2-7-4】注释应当准确、易懂，防止注释有二义性。错误的注释不但无益反而有害。
+ 【规则2-7-5】尽量避免在注释中使用缩写，特别是不常用缩写。
+ 【规则2-7-6】注释的位置应与被描述的代码相邻，可以放在代码的上方或右方，不可放在下方。
+ 【规则2-7-8】当代码比较长，特别是有多重嵌套时，应当在一些段落的结束处加注释，便于阅读。

示例 2-6：程序的注释

```c
/**
************************************************************************
* @brief:      	function(float x, float y, float z)
* @param[in]:   x:      y:      z:
* @param[out]:  void
* @retval:     	void
* @details:    	函数功能
************************************************************************
**/
void function(float x, float y, float z) 
{
    if (...)
    {     
        ...      
        while  (...)      
		{  
			... 
		} // end of while
        ... 
    } // end of if 
    ... 
} 
```



---

## 3 命名规则

比较著名的命名规则当推Microsoft公司的“匈牙利”法，该命名规则的主要思想是“在变量和函数名中加入前缀以增进人们对程序的理解”。例如所有的字符变量均以ch为前缀，若是指针变量则追加前缀p。如果一个变量由ppch开头，则表明它是指向字符指针的指针。

“匈牙利”法最大的缺点是烦琐，例如：

```c
int    i,  j,  k;   
float  x,  y,  z; 
```

倘若采用“匈牙利”命名规则，则应当写成：

```c
int    iI,  iJ,  ik;  // 前缀 i表示int类型
float  fX,  fY,  fZ;  // 前缀 f表示float类型
```

如此烦琐的程序会让绝大多数程序员无法忍受。

据考察，没有一种命名规则可以让所有的程序员赞同，程序设计教科书一般都不指定命名规则。命名规则对软件产品而言并不是“成败悠关”的事，我们不要化太多精力试图发明世界上最好的命名规则，而应当制定一种令大多数项目成员满意的命名规则，并在项目中贯彻实施。

### 3.1 共性规则

+ 【规则3-1-1】标识符应当直观且可以拼读，可望文知意，不必进行“解码”。

标识符最好采用英文单词或其组合，便于记忆和阅读。切忌使用汉语拼音来命名。程序中的英文单词一般不会太复杂，用词应当准确。例如不要把 CurrentValue 写成 NowValue 。

+ 【规则3-1-2】标识符的长度应当符合 “min-length && max-information” 原则。

几十年前老ANSI  C规定名字不准超过6个字符，现今的 C++/C 不再有此限制。一般来说，长名字能更好地表达含义，所以函数名、变量名、类名长达十几个字符不足为怪。那么名字是否越长约好？不见得! 例如变量名maxval就比maxValueUntilOverflow好用。单字符的名字也是有用的，常见的如i,j,k,m,n,x,y,z等，它们通常可用作函数内的局部变量。

+ 【规则3-1-3】命名规则尽量与所采用的操作系统或开发工具的风格保持一致。

例如Windows应用程序的标识符通常采用 “大小写” 混排的方式，如 AddChild。而Unix应用程序的标识符通常采用“小写加下划线”的方式，如 add_child。别把这两类风格混在一起用。

+ 【规则3-1-4】程序中不要出现仅靠大小写区分的相似的标识符。

例如：

```c
int  x,  X;        // 变量x 与 X 容易混淆
void foo(int x);   // 函数foo 与FOO容易混淆
void FOO(float x); 
```

+ 【规则3-1-5】程序中不要出现标识符完全相同的局部变量和全局变量，尽管两者的作用域不同而不会发生语法错误，但会使人误解。

+ 【规则3-1-6】变量的名字应当使用“名词”或者“形容词＋名词”。

例如：

```c
float    value;  
float    oldValue;  
float    newValue;  
```

+ 【规则3-1-7】全局函数的名字应当使用“动词”或者“动词＋名词”（动宾词组）。类的成员函数应当只使用“动词”，被省略掉的名词就是对象本身。

例如：

```c
DrawBox();      // 全局函数                
box->Draw();    // 类的成员函数
```

+ 【规则3-1-8】用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。

例如：

```c
int  minValue;  
int  maxValue;  
int  SetValue(...);  
int  GetValue(...);  
```

+ 【建议3-1-1】尽量避免名字中出现数字编号，如 Value1, Value2 等，除非逻辑上的确需要编号。这是为了防止程序员偷懒，不肯为命名动脑筋而导致产生无意义的名字（因为用数字编号最省事）。

### 3.2 简单的 Windows 应用程序命名规则

+ 【规则3-2-1】类名和函数名用大写字母开头的单词组合而成。

例如：  

```c
class  Node;      	// 类名    
class  LeafNode; 	// 类名  
void  Draw(void);	// 函数名  
void  SetValue(int value); // 函数名
```

+ 【规则3-2-2】变量和参数用小写字母开头的单词组合而成。

例如：   

```c
bool flag;        
int  drawMode; 
```

+ 【规则3-2-3】常量全用大写的字母，用下划线分割单词。

例如：   

```c
const int MAX = 100;     
const int MAX_LENGTH = 100; 
```

+ 【规则3-2-4】静态变量加前缀s\_（表示static）。

例如：

```c
void Init(...) 
{ 
    static int s_initValue; // 静态变量        
    ...       
} 
```

+ 【规则3-2-5】如果不得已需要全局变量，则使全局变量加前缀g\_（表示global）。

例如：

```c
int g_howManyPeople; // 全局变量
int g_howMuchMoney;  // 全局变量
```

+ 【规则3-2-6】类的数据成员加前缀m_（表示member），这样可以避免数据成员与成员函数的参数同名。

例如：

```c
void Object::SetValue(int width, int height) 
{     
    m_width = width; 
    m_height = height; 
} 
```

+ 【规则3-2-7】为了防止某一软件库中的一些标识符和其它软件库中的冲突，可以为各种标识符加上能反映软件性质的前缀。例如三维图形标准OpenGL的所有库函数均以gl开头，所有常量（或宏定义）均以 GL 开头。

### 3.3 简单的 Unix 应用程序命名规则

Linux作为GNU家族的一员，上面的源代码数以万计，而在阅读这些源代码时我们会发现，不同的源代码的美观程度和编程风格都不尽一样，有些代码，比如 Linux 内核链表的代码:

```c
static inline void __list_del_entry(struct list_head *entry)
{
	if (!__list_del_entry_valid(entry))
		return;

	__list_del(entry->prev, entry->next);
}
```

+ 【规则3-3-1】函数名使用下划线分割小写字母的方式。

> 设备名_操作名()

操作名一般采用：谓语（此时设备名作为宾语或者标明操作所属的模块）或者谓语+宾语/表语（此时设备名作为主语或者标明操作所属的模块)等形式，如:操作名一般采用:谓语(此时设备名作为宾语或者标明操作所属的模块)或者谓语+宾语/表语(此时设备名作为主语或者标明操作所属的模块)等形式，如：

```c
void  tick_init(void);	 // 函数名  
void  adc_ix_busy(void); // 函数名
void  uart_tx_char(void);// 函数名
```

中断函数的命名直接使用设备名 \_isr() 的形式命名，如:
```c
void timer_isr(void);
```
+ 【规则3-3-2】变量和参数用小写字母开头的单词组合而成。

例如：   

```c
bool flag;        
int  draw_mode; 
```

+ 【规则3-3-3】常量以及宏用大写的字母，用下划线分割单词。

例如：   

```c
const int MAX = 100;     
const int MAX_LENGTH = 100; 

#define TIMER_MODE_RELOAD 2
#define TIMER_COUNT_RETRIEVE(val) ((uint16)(65536 - (val)))
```

当然看作接口的宏可以用函数的命名方法命名：

```c
#define list_first_entry_or_null(ptr, type, member) ({ \
	struct list_head *head__ = (ptr); \
	struct list_head *pos__ = READ_ONCE(head__->next); \
	pos__ != head__ ? list_entry(pos__, type, member) : NULL; \
})
```

+ 【规则3-3-4】静态变量加前缀s\_（表示static）。

例如：

```c
void init(...) 
{ 
    static int s_value; // 静态变量        
    ...       
} 
```

+ 【规则3-3-5】如果不得已需要全局变量，则使全局变量加前缀g\_（表示global）。

例如：

```c
int g_how_many_people; // 全局变量
int g_how_much_money;  // 全局变量
```

##  4 一些有益的建议

+ 当心那些视觉上不易分辨的操作符发生书写错误。我们经常会把“＝＝”误写成“＝”，象“||”、“&&”、“<=”、“>=”这类符号也很容易发生“丢1”失误。然而编译器却不一定能自动指出这类错误。
+ 变量（指针、数组）被创建之后应当及时把它们初始化，以防止把未被初始化的变量当成右值使用。【建议11-3-3】当心变量的初值、缺省值错误，或者精度不够。
+ 当心数据类型转换发生错误。尽量使用显式的数据类型转换（让人们知道发生了什么事），避免让编译器轻悄悄地进行隐式的数据类型转换。
+ 当心变量发生上溢或下溢，数组的下标越界。
+ 当心忘记编写错误处理程序，当心错误处理程序本身有误。
+ 当心文件I/O有错误。
+ 避免编写技巧性很高代码，不要设计面面俱到、非常灵活的数据结构。
+ 如果原有的代码质量比较好，尽量复用它。但是不要修补很差劲的代码，应当重新编写。

+ 没有一种命名规则可以让所有的程序员赞同。而这多种命名规则也确实各有利弊。

+ 没有必要花太多的精力试图发明最好的命名规则，而是应当制定一种令大多数项目成员满意的命名规则并切实执行。标识符命名的一致性自然会体现出代码的优雅。当然，如果程序使用了第三方的代码，而这些模块经验证确实是正确无误的。那么也没有必要一味追求命名的一致性，而去修改这些已经定型的模块中的函数和变量名。



参考文献:
[1]高质量程序设计指南——C/C++语言，林锐

[2]unix_linux应用程序命名法















